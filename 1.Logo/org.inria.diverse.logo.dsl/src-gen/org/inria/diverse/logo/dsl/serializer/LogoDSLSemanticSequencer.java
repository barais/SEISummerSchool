/*
 * generated by Xtext
 */
package org.inria.diverse.logo.dsl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.inria.diverse.logo.dsl.logoDSL.BOLD;
import org.inria.diverse.logo.dsl.logoDSL.CANVAS_COLOR;
import org.inria.diverse.logo.dsl.logoDSL.CLEAR;
import org.inria.diverse.logo.dsl.logoDSL.COLOR_SPEC;
import org.inria.diverse.logo.dsl.logoDSL.CONTENT;
import org.inria.diverse.logo.dsl.logoDSL.DIVIDE;
import org.inria.diverse.logo.dsl.logoDSL.DRAW_STRING;
import org.inria.diverse.logo.dsl.logoDSL.EQUALS;
import org.inria.diverse.logo.dsl.logoDSL.FONT_STYLE;
import org.inria.diverse.logo.dsl.logoDSL.FORWARD;
import org.inria.diverse.logo.dsl.logoDSL.GREATER_THAN;
import org.inria.diverse.logo.dsl.logoDSL.HOME;
import org.inria.diverse.logo.dsl.logoDSL.IF_SENTENCE;
import org.inria.diverse.logo.dsl.logoDSL.ITALIC;
import org.inria.diverse.logo.dsl.logoDSL.LEFT;
import org.inria.diverse.logo.dsl.logoDSL.LESSER_THAN;
import org.inria.diverse.logo.dsl.logoDSL.LogoDSLPackage;
import org.inria.diverse.logo.dsl.logoDSL.LogoProgram;
import org.inria.diverse.logo.dsl.logoDSL.MAKE;
import org.inria.diverse.logo.dsl.logoDSL.MULTIPLY;
import org.inria.diverse.logo.dsl.logoDSL.PARAM;
import org.inria.diverse.logo.dsl.logoDSL.PENCOLOR;
import org.inria.diverse.logo.dsl.logoDSL.PENDOWN;
import org.inria.diverse.logo.dsl.logoDSL.PENUP;
import org.inria.diverse.logo.dsl.logoDSL.PLAIN;
import org.inria.diverse.logo.dsl.logoDSL.PROCEDURE_CALL;
import org.inria.diverse.logo.dsl.logoDSL.REPEAT;
import org.inria.diverse.logo.dsl.logoDSL.RIGHT;
import org.inria.diverse.logo.dsl.logoDSL.SET_X;
import org.inria.diverse.logo.dsl.logoDSL.SET_Y;
import org.inria.diverse.logo.dsl.logoDSL.SUBTRACT;
import org.inria.diverse.logo.dsl.logoDSL.SUM;
import org.inria.diverse.logo.dsl.logoDSL.TO;
import org.inria.diverse.logo.dsl.logoDSL.VALUE;
import org.inria.diverse.logo.dsl.logoDSL.VARIABLE_REF;
import org.inria.diverse.logo.dsl.services.LogoDSLGrammarAccess;

@SuppressWarnings("all")
public class LogoDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LogoDSLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == LogoDSLPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case LogoDSLPackage.BOLD:
				sequence_FontStyleValues(context, (BOLD) semanticObject); 
				return; 
			case LogoDSLPackage.CANVAS_COLOR:
				sequence_CANVAS_COLOR(context, (CANVAS_COLOR) semanticObject); 
				return; 
			case LogoDSLPackage.CLEAR:
				sequence_CLEAR(context, (CLEAR) semanticObject); 
				return; 
			case LogoDSLPackage.COLOR_SPEC:
				sequence_COLOR_SPEC(context, (COLOR_SPEC) semanticObject); 
				return; 
			case LogoDSLPackage.CONTENT:
				sequence_CONTENT(context, (CONTENT) semanticObject); 
				return; 
			case LogoDSLPackage.DIVIDE:
				sequence_DIVIDE(context, (DIVIDE) semanticObject); 
				return; 
			case LogoDSLPackage.DRAW_STRING:
				sequence_DRAW_STRING(context, (DRAW_STRING) semanticObject); 
				return; 
			case LogoDSLPackage.EQUALS:
				sequence_EQUALS(context, (EQUALS) semanticObject); 
				return; 
			case LogoDSLPackage.FONT_STYLE:
				sequence_FONT_STYLE(context, (FONT_STYLE) semanticObject); 
				return; 
			case LogoDSLPackage.FORWARD:
				sequence_FORWARD(context, (FORWARD) semanticObject); 
				return; 
			case LogoDSLPackage.GREATER_THAN:
				sequence_GREATER_THAN(context, (GREATER_THAN) semanticObject); 
				return; 
			case LogoDSLPackage.HOME:
				sequence_HOME(context, (HOME) semanticObject); 
				return; 
			case LogoDSLPackage.IF_SENTENCE:
				sequence_IF_SENTENCE(context, (IF_SENTENCE) semanticObject); 
				return; 
			case LogoDSLPackage.ITALIC:
				sequence_FontStyleValues(context, (ITALIC) semanticObject); 
				return; 
			case LogoDSLPackage.LEFT:
				sequence_LEFT(context, (LEFT) semanticObject); 
				return; 
			case LogoDSLPackage.LESSER_THAN:
				sequence_LESSER_THAN(context, (LESSER_THAN) semanticObject); 
				return; 
			case LogoDSLPackage.LOGO_PROGRAM:
				sequence_LogoProgram(context, (LogoProgram) semanticObject); 
				return; 
			case LogoDSLPackage.MAKE:
				sequence_MAKE(context, (MAKE) semanticObject); 
				return; 
			case LogoDSLPackage.MULTIPLY:
				sequence_MULTIPLY(context, (MULTIPLY) semanticObject); 
				return; 
			case LogoDSLPackage.PARAM:
				sequence_PARAM(context, (PARAM) semanticObject); 
				return; 
			case LogoDSLPackage.PENCOLOR:
				sequence_PENCOLOR(context, (PENCOLOR) semanticObject); 
				return; 
			case LogoDSLPackage.PENDOWN:
				sequence_PENDOWN(context, (PENDOWN) semanticObject); 
				return; 
			case LogoDSLPackage.PENUP:
				sequence_PENUP(context, (PENUP) semanticObject); 
				return; 
			case LogoDSLPackage.PLAIN:
				sequence_FontStyleValues(context, (PLAIN) semanticObject); 
				return; 
			case LogoDSLPackage.PROCEDURE_CALL:
				sequence_PROCEDURE_CALL(context, (PROCEDURE_CALL) semanticObject); 
				return; 
			case LogoDSLPackage.REPEAT:
				sequence_REPEAT(context, (REPEAT) semanticObject); 
				return; 
			case LogoDSLPackage.RIGHT:
				sequence_RIGHT(context, (RIGHT) semanticObject); 
				return; 
			case LogoDSLPackage.SET_X:
				sequence_SET_X(context, (SET_X) semanticObject); 
				return; 
			case LogoDSLPackage.SET_Y:
				sequence_SET_Y(context, (SET_Y) semanticObject); 
				return; 
			case LogoDSLPackage.SUBTRACT:
				sequence_SUBTRACT(context, (SUBTRACT) semanticObject); 
				return; 
			case LogoDSLPackage.SUM:
				sequence_SUM(context, (SUM) semanticObject); 
				return; 
			case LogoDSLPackage.TO:
				sequence_TO(context, (TO) semanticObject); 
				return; 
			case LogoDSLPackage.VALUE:
				sequence_VALUE(context, (VALUE) semanticObject); 
				return; 
			case LogoDSLPackage.VARIABLE_REF:
				sequence_VARIABLE_REF(context, (VARIABLE_REF) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (color=COLOR | colorSpec=COLOR_SPEC)
	 */
	protected void sequence_CANVAS_COLOR(EObject context, CANVAS_COLOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {CLEAR}
	 */
	protected void sequence_CLEAR(EObject context, CLEAR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (red=EXPRESSION green=EXPRESSION blue=EXPRESSION alpha=EXPRESSION)
	 */
	protected void sequence_COLOR_SPEC(EObject context, COLOR_SPEC semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__RED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__RED));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__GREEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__GREEN));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__BLUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__BLUE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__ALPHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.COLOR_SPEC__ALPHA));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCOLOR_SPECAccess().getRedEXPRESSIONParserRuleCall_0_0(), semanticObject.getRed());
		feeder.accept(grammarAccess.getCOLOR_SPECAccess().getGreenEXPRESSIONParserRuleCall_1_0(), semanticObject.getGreen());
		feeder.accept(grammarAccess.getCOLOR_SPECAccess().getBlueEXPRESSIONParserRuleCall_2_0(), semanticObject.getBlue());
		feeder.accept(grammarAccess.getCOLOR_SPECAccess().getAlphaEXPRESSIONParserRuleCall_3_0(), semanticObject.getAlpha());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     var=[MAKE|ID]
	 */
	protected void sequence_CONTENT(EObject context, CONTENT semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.CONTENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.CONTENT__VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCONTENTAccess().getVarMAKEIDTerminalRuleCall_1_0_1(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (targetVariable=[MAKE|ID] valOne=EXPRESSION valTwo=EXPRESSION)
	 */
	protected void sequence_DIVIDE(EObject context, DIVIDE semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDIVIDEAccess().getTargetVariableMAKEIDTerminalRuleCall_1_0_1(), semanticObject.getTargetVariable());
		feeder.accept(grammarAccess.getDIVIDEAccess().getValOneEXPRESSIONParserRuleCall_3_0(), semanticObject.getValOne());
		feeder.accept(grammarAccess.getDIVIDEAccess().getValTwoEXPRESSIONParserRuleCall_5_0(), semanticObject.getValTwo());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_DRAW_STRING(EObject context, DRAW_STRING semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.DRAW_STRING__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.DRAW_STRING__TEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDRAW_STRINGAccess().getTextSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (op1=EXPRESSION op2=EXPRESSION)
	 */
	protected void sequence_EQUALS(EObject context, EQUALS semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP1));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEQUALSAccess().getOp1EXPRESSIONParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getEQUALSAccess().getOp2EXPRESSIONParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     style=FontStyleValues
	 */
	protected void sequence_FONT_STYLE(EObject context, FONT_STYLE semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.FONT_STYLE__STYLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.FONT_STYLE__STYLE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFONT_STYLEAccess().getStyleFontStyleValuesParserRuleCall_1_0(), semanticObject.getStyle());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     amount=EXPRESSION
	 */
	protected void sequence_FORWARD(EObject context, FORWARD semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFORWARDAccess().getAmountEXPRESSIONParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {BOLD}
	 */
	protected void sequence_FontStyleValues(EObject context, BOLD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ITALIC}
	 */
	protected void sequence_FontStyleValues(EObject context, ITALIC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {PLAIN}
	 */
	protected void sequence_FontStyleValues(EObject context, PLAIN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (op1=EXPRESSION op2=EXPRESSION)
	 */
	protected void sequence_GREATER_THAN(EObject context, GREATER_THAN semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP1));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGREATER_THANAccess().getOp1EXPRESSIONParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getGREATER_THANAccess().getOp2EXPRESSIONParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {HOME}
	 */
	protected void sequence_HOME(EObject context, HOME semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=BOOLEAN_EXPRESSION commands+=SENTENCE+)
	 */
	protected void sequence_IF_SENTENCE(EObject context, IF_SENTENCE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     amount=EXPRESSION
	 */
	protected void sequence_LEFT(EObject context, LEFT semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLEFTAccess().getAmountEXPRESSIONParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (op1=EXPRESSION op2=EXPRESSION)
	 */
	protected void sequence_LESSER_THAN(EObject context, LESSER_THAN semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP1));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.BOOLEAN_EXPRESSION__OP2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLESSER_THANAccess().getOp1EXPRESSIONParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getLESSER_THANAccess().getOp2EXPRESSIONParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     sentences+=SENTENCE*
	 */
	protected void sequence_LogoProgram(EObject context, LogoProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=EXPRESSION)
	 */
	protected void sequence_MAKE(EObject context, MAKE semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.REFERENCIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.REFERENCIABLE__NAME));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.MAKE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.MAKE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMAKEAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMAKEAccess().getValueEXPRESSIONParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (targetVariable=[MAKE|ID] valOne=EXPRESSION valTwo=EXPRESSION)
	 */
	protected void sequence_MULTIPLY(EObject context, MULTIPLY semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMULTIPLYAccess().getTargetVariableMAKEIDTerminalRuleCall_1_0_1(), semanticObject.getTargetVariable());
		feeder.accept(grammarAccess.getMULTIPLYAccess().getValOneEXPRESSIONParserRuleCall_3_0(), semanticObject.getValOne());
		feeder.accept(grammarAccess.getMULTIPLYAccess().getValTwoEXPRESSIONParserRuleCall_5_0(), semanticObject.getValTwo());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PARAM(EObject context, PARAM semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.REFERENCIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.REFERENCIABLE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPARAMAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (color=COLOR | colorSpec=COLOR_SPEC)
	 */
	protected void sequence_PENCOLOR(EObject context, PENCOLOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {PENDOWN}
	 */
	protected void sequence_PENDOWN(EObject context, PENDOWN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {PENUP}
	 */
	protected void sequence_PENUP(EObject context, PENUP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (to=[TO|ID] params+=EXPRESSION*)
	 */
	protected void sequence_PROCEDURE_CALL(EObject context, PROCEDURE_CALL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (times=EXPRESSION commands+=SENTENCE+)
	 */
	protected void sequence_REPEAT(EObject context, REPEAT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     amount=EXPRESSION
	 */
	protected void sequence_RIGHT(EObject context, RIGHT semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRIGHTAccess().getAmountEXPRESSIONParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     amount=EXPRESSION
	 */
	protected void sequence_SET_X(EObject context, SET_X semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSET_XAccess().getAmountEXPRESSIONParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     amount=EXPRESSION
	 */
	protected void sequence_SET_Y(EObject context, SET_Y semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.MOVE__AMOUNT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSET_YAccess().getAmountEXPRESSIONParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (targetVariable=[MAKE|ID] valOne=EXPRESSION valTwo=EXPRESSION)
	 */
	protected void sequence_SUBTRACT(EObject context, SUBTRACT semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSUBTRACTAccess().getTargetVariableMAKEIDTerminalRuleCall_1_0_1(), semanticObject.getTargetVariable());
		feeder.accept(grammarAccess.getSUBTRACTAccess().getValOneEXPRESSIONParserRuleCall_3_0(), semanticObject.getValOne());
		feeder.accept(grammarAccess.getSUBTRACTAccess().getValTwoEXPRESSIONParserRuleCall_5_0(), semanticObject.getValTwo());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (targetVariable=[MAKE|ID] valOne=EXPRESSION valTwo=EXPRESSION)
	 */
	protected void sequence_SUM(EObject context, SUM semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__TARGET_VARIABLE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_ONE));
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.OPERATION__VAL_TWO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSUMAccess().getTargetVariableMAKEIDTerminalRuleCall_1_0_1(), semanticObject.getTargetVariable());
		feeder.accept(grammarAccess.getSUMAccess().getValOneEXPRESSIONParserRuleCall_3_0(), semanticObject.getValOne());
		feeder.accept(grammarAccess.getSUMAccess().getValTwoEXPRESSIONParserRuleCall_5_0(), semanticObject.getValTwo());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID parameters+=PARAM* commands+=SENTENCE+)
	 */
	protected void sequence_TO(EObject context, TO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=DOUBLE
	 */
	protected void sequence_VALUE(EObject context, VALUE semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.VALUE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.VALUE__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVALUEAccess().getValDOUBLETerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     toVar=[REFERENCIABLE|ID]
	 */
	protected void sequence_VARIABLE_REF(EObject context, VARIABLE_REF semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LogoDSLPackage.Literals.VARIABLE_REF__TO_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoDSLPackage.Literals.VARIABLE_REF__TO_VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVARIABLE_REFAccess().getToVarREFERENCIABLEIDTerminalRuleCall_0_1(), semanticObject.getToVar());
		feeder.finish();
	}
}
